# Manage and access multinetwork dimensions


## Dimension data structure

function _initialize_dim()
    Dict{Symbol,Any}(
        :pos  => NamedTuple(), # Position (order) of each dimension
        :prop => Dict{Symbol,Dict{Int,Dict{String,Any}}}(), # Data relating to the elements of the dimensions
        :meta => Dict{Symbol,Any}() # Data relating to dimensions
        # li (linear indices): generated by add_dimension!()
        # ci (cartesian indices): generated by add_dimension!()
    )
end

"""
    add_dimension!(data, name, properties; metadata)

Add dimension `name` to `data` specifying some `properties` of the dimension ids.

# Arguments
- `data::Dict{String,Any}`: a single-network data structure.
- `name::Symbol`: the name to use to refer to the dimension in the code.
- `properties::Dict{Int,Dict{String,Any}}`: properties associated to the dimension ids. The
  outer dictionary is indexed with the ids along the dimension (consecutive `Int`s starting
  from 1). The inner dictionaries, one for each id, store the properties.
- `metadata::Dict{String,Any} = Dict{String,Any}()`: optional metadata describing the
  dimension as a whole.

# Examples
```julia-repl
julia> add_dimension!(data, :scenario, Dict(s => Dict{String,Any}("probability"=>1/4) for s in 1:4))
```

# Extended help
The functions `dim_prop`, `dim_meta` and `dim_length` can be used to access properties,
metadata and length (cardinality) of a dimension. They apply to both data dictionaries
(`Dict{String,Any}`) and powermodels (`PowerModels.AbstractPowerModel`).
"""
function add_dimension!(data::Dict{String,Any}, name::Symbol, properties::Dict{Int,Dict{String,Any}}; metadata::Dict{String,Any}=Dict{String,Any}())
    dim = get!(data, "dim", _initialize_dim())

    if haskey(dim, name)
        Memento.error(_LOGGER, "A dimension named \"$name\" is already present in data.")
    end
    if Set(keys(properties)) != Set(1:length(properties))
        Memento.error(_LOGGER, "Keys of `properties` Dict must range from 1 to the number of $(name)s.")
    end

    dim[:pos] = (; dim[:pos]..., name => length(dim[:pos])+1)
    dim[:prop][name] = properties
    dim[:meta][name] = metadata
    dim[:li] = collect(LinearIndices(Tuple(1:length(dim[:prop][nm]) for nm in keys(dim[:pos]))))
    dim[:ci] = CartesianIndices(dim[:li])

    return dim
end

"""
    add_dimension!(data, name, size; metadata)

Add dimension `name` to `data` specifying the dimension `size`.

# Examples
```julia-repl
julia> add_dimension!(data, :hour, 24)
```
"""
function add_dimension!(data::Dict{String,Any}, name::Symbol, size::Int; metadata::Dict{String,Any}=Dict{String,Any}())
    properties = Dict{Int,Dict{String,Any}}(i => Dict{String,Any}() for i in 1:size)
    add_dimension!(data, name, properties; metadata)
end


## Access (subsets of) nw ids

"""
    nw_ids(pm::PowerModels.AbstractPowerModel; kwargs...)

Sorted vector containing nw ids of `pm`, optionally filtered by the value of one or more dimensions.

`kwargs` must be of the form `name = <value>` or `name = <interval>` or `name = <subset>`,
where `name` is the name of a dimension of `pm`.

# Examples
```julia-repl
julia> nw_ids(pm)
julia> nw_ids(pm; hour = 24)
julia> nw_ids(pm; hour = 13:24)
julia> nw_ids(pm; hour = [6,12,18,24])
julia> nw_ids(pm; hour = 24, scenario = 3)
```
"""
function nw_ids(pm::_PM.AbstractPowerModel; kwargs...)::Vector{Int}
    if !haskey(pm.ref, :dim)
        return [0]
    end
    dim = pm.ref[:dim]
    names = keys(dim[:pos])
    nws = dim[:li][ntuple(i -> get(kwargs, names[i], axes(dim[:li], i)), ndims(dim[:li]))...]
    ndims(nws) >= 1 ? vec(nws) : [nws]
end


## Compute nw ids given another nw id

"""
    similar_ids(pm::PowerModels.AbstractPowerModel, n::Int; kwargs...)

Sorted vector containing nw ids that have the same coordinates along dimensions as `n` except for dimensions passed in `kwargs`.

`kwargs` must be of the form `name = <value>` or `name = <interval>` or `name = <subset>`,
where `name` is the name of a dimension of `pm`.

# Examples
```julia-repl
julia> similar_ids(pm, 3; hour = 24)
julia> similar_ids(pm, 3; hour = 13:24)
julia> similar_ids(pm, 3; hour = [6,12,18,24])
julia> similar_ids(pm, 3; hour = 24, scenario = 3)
```
"""
function similar_ids(pm::_PM.AbstractPowerModel, n::Int; kwargs...)::Vector{Int}
    dim = pm.ref[:dim]
    names = keys(dim[:pos])
    ci_n = dim[:ci][n]
    nws = dim[:li][ntuple(i -> get(kwargs, names[i], ci_n[i]), ndims(dim[:li]))...]
    ndims(nws) >= 1 ? vec(nws) : [nws]
end

"""
    similar_id(pm::PowerModels.AbstractPowerModel, n::Int; kwargs...)

Nw id that has the same coordinates along dimensions as `n` except for dimensions passed in `kwargs`.

`kwargs` must be of the form `name = <value>`, where `name` is the name of a dimension of
`pm`.

# Examples
```julia-repl
julia> similar_id(pm, 3; hour = 24)
julia> similar_id(pm, 3; hour = 24, scenario = 3)
```
"""
function similar_id(pm::_PM.AbstractPowerModel, n::Int; kwargs...)::Int
    dim = pm.ref[:dim]
    names = keys(dim[:pos])
    ci_n = dim[:ci][n]
    dim[:li][ntuple(i -> get(kwargs, names[i], ci_n[i])::Int, ndims(dim[:li]))...]
end

"""
    first_nw(pm::PowerModels.AbstractPowerModel, n::Int, dimension::Symbol...)

Return the first network in `pm` along `dimension` while keeping the other dimensions fixed.
"""
function first_nw(pm::_PM.AbstractPowerModel, n::Int, dimension::Symbol...)
    dim = pm.ref[:dim]
    names = keys(dim[:pos])
    li = dim[:li]
    ci_n = dim[:ci][n]
    li[ntuple(i -> names[i] in dimension ? 1 : ci_n[i], ndims(li))...]
end

"""
    last_nw(pm::PowerModels.AbstractPowerModel, n::Int, dimension::Symbol...)

Return the last network in `pm` along `dimension` while keeping the other dimensions fixed.
"""
function last_nw(pm::_PM.AbstractPowerModel, n::Int, dimension::Symbol...)
    dim = pm.ref[:dim]
    names = keys(dim[:pos])
    li = dim[:li]
    ci_n = dim[:ci][n]
    li[ntuple(i -> names[i] in dimension ? size(li,i) : ci_n[i], ndims(li))...]
end

"""
    prev_nw(pm::PowerModels.AbstractPowerModel, n::Int, dimension::Symbol)

Return the previous network in `pm` along `dimension` while keeping the other dimensions fixed.
"""
function prev_nw(pm::_PM.AbstractPowerModel, n::Int, dimension::Symbol)
    dim = pm.ref[:dim]
    pos_d = dim[:pos][dimension]
    li = dim[:li]
    ci_n = dim[:ci][n]
    li[ntuple(i -> i == pos_d ? ci_n[i]-1 : ci_n[i], ndims(li))...]
end

"""
    next_nw(pm::PowerModels.AbstractPowerModel, n::Int, dimension::Symbol)

Return the next network in `pm` along `dimension` while keeping the other dimensions fixed.
"""
function next_nw(pm::_PM.AbstractPowerModel, n::Int, dimension::Symbol)
    dim = pm.ref[:dim]
    pos_d = dim[:pos][dimension]
    li = dim[:li]
    ci_n = dim[:ci][n]
    li[ntuple(i -> i == pos_d ? ci_n[i]+1 : ci_n[i], ndims(li))...]
end


## Query properties of nw ids

"""
    is_first_nw(pm::PowerModels.AbstractPowerModel, n::Int, dimension::Symbol...)

Return whether the network `n` is the first along `dimension` in `pm`.
"""
function is_first_nw(pm::_PM.AbstractPowerModel, n::Int, dimension::Symbol...)
    dim = pm.ref[:dim]
    pos = dim[:pos]
    ci_n = dim[:ci][n]
    all(ci_n[pos[d]] == 1 for d in dimension)
end

"""
    is_last_nw(pm::PowerModels.AbstractPowerModel, n::Int, dimension::Symbol...)

Return whether the network `n` is the last along `dimension` in `pm`.
"""
function is_last_nw(pm::_PM.AbstractPowerModel, n::Int, dimension::Symbol...)
    dim = pm.ref[:dim]
    pos = dim[:pos]
    li = dim[:li]
    ci_n = dim[:ci][n]
    all(ci_n[pos[d]] == size(li,pos[d]) for d in dimension)
end


## Access data relating to dimensions

dim_prop(data::Dict{String,Any}) = data["dim"][:prop]
dim_prop(data::Dict{String,Any}, name::Symbol) = data["dim"][:prop][name]
dim_prop(data::Dict{String,Any}, name::Symbol, id::Int) = data["dim"][:prop][name][id]
dim_prop(data::Dict{String,Any}, name::Symbol, id::Int, key::String) = data["dim"][:prop][name][id][key]

dim_prop(pm::_PM.AbstractPowerModel) = pm.ref[:dim][:prop]
dim_prop(pm::_PM.AbstractPowerModel, name::Symbol) = pm.ref[:dim][:prop][name]
dim_prop(pm::_PM.AbstractPowerModel, name::Symbol, id::Int) = pm.ref[:dim][:prop][name][id]
dim_prop(pm::_PM.AbstractPowerModel, name::Symbol, id::Int, key::String) = pm.ref[:dim][:prop][name][id][key]

dim_meta(data::Dict{String,Any}) = data["dim"][:meta]
dim_meta(data::Dict{String,Any}, name::Symbol) = data["dim"][:meta][name]
dim_meta(data::Dict{String,Any}, name::Symbol, key::String) = data["dim"][:meta][name][key]

dim_meta(pm::_PM.AbstractPowerModel) = pm.ref[:dim][:meta]
dim_meta(pm::_PM.AbstractPowerModel, name::Symbol) = pm.ref[:dim][:meta][name]
dim_meta(pm::_PM.AbstractPowerModel, name::Symbol, key::String) = pm.ref[:dim][:meta][name][key]

function dim_length(data::Dict{String,Any}, name::Symbol)
    dim = data["dim"]
    size(dim[:li], dim[:pos][name])
end

function dim_length(pm::_PM.AbstractPowerModel, name::Symbol)
    dim = pm.ref[:dim]
    size(dim[:li], dim[:pos][name])
end
